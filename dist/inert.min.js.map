{"version":3,"file":"inert.min.js","sources":["../src/inert.js"],"sourcesContent":["/**\n * This work is licensed under the W3C Software and Document License\n * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n */\n\n(function() {\n  // Return early if we're not running inside of the browser.\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  // Convenience function for converting NodeLists.\n  /** @type {typeof Array.prototype.slice} */\n  const slice = Array.prototype.slice;\n\n  /**\n   * IE has a non-standard name for \"matches\".\n   * @type {typeof Element.prototype.matches}\n   */\n  const matches =\n      Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n  /** @type {string} */\n  const _focusableElementsString = ['a[href]',\n                                    'area[href]',\n                                    'input:not([disabled])',\n                                    'select:not([disabled])',\n                                    'textarea:not([disabled])',\n                                    'button:not([disabled])',\n                                    'details',\n                                    'summary',\n                                    'iframe',\n                                    'object',\n                                    'embed',\n                                    '[contenteditable]'].join(',');\n\n  /**\n   * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n   * attribute.\n   *\n   * Its main functions are:\n   *\n   * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n   *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n   *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n   *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n   *   instance exists for each focusable node which has at least one inert root as an ancestor.\n   *\n   * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n   *   attribute is removed from the root node). This is handled in the destructor, which calls the\n   *   `deregister` method on `InertManager` for each managed inert node.\n   */\n  class InertRoot {\n    /**\n     * @param {!Element} rootElement The Element at the root of the inert subtree.\n     * @param {!InertManager} inertManager The global singleton InertManager object.\n     */\n    constructor(rootElement, inertManager) {\n      /** @type {!InertManager} */\n      this._inertManager = inertManager;\n\n      /** @type {!Element} */\n      this._rootElement = rootElement;\n\n      /**\n       * @type {!Set<!InertNode>}\n       * All managed focusable nodes in this InertRoot's subtree.\n       */\n      this._managedNodes = new Set();\n\n      // Make the subtree hidden from assistive technology\n      if (this._rootElement.hasAttribute('aria-hidden')) {\n        /** @type {?string} */\n        this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n      } else {\n        this._savedAriaHidden = null;\n      }\n      this._rootElement.setAttribute('aria-hidden', 'true');\n\n      // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n      this._makeSubtreeUnfocusable(this._rootElement);\n\n      // Watch for:\n      // - any additions in the subtree: make them unfocusable too\n      // - any removals from the subtree: remove them from this inert root's managed nodes\n      // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n      //   element, make that node a managed node.\n      this._observer = new MutationObserver(this._onMutation.bind(this));\n      this._observer.observe(this._rootElement, {attributes: true, childList: true, subtree: true});\n    }\n\n    /**\n     * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n     * stored in this object and updates the state of all of the managed nodes.\n     */\n    destructor() {\n      this._observer.disconnect();\n\n      if (this._rootElement) {\n        if (this._savedAriaHidden !== null) {\n          this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n        } else {\n          this._rootElement.removeAttribute('aria-hidden');\n        }\n      }\n\n      this._managedNodes.forEach(function(inertNode) {\n        this._unmanageNode(inertNode.node);\n      }, this);\n\n      // Note we cast the nulls to the ANY type here because:\n      // 1) We want the class properties to be declared as non-null, or else we\n      //    need even more casts throughout this code. All bets are off if an\n      //    instance has been destroyed and a method is called.\n      // 2) We don't want to cast \"this\", because we want type-aware optimizations\n      //    to know which properties we're setting.\n      this._observer = /** @type {?} */ (null);\n      this._rootElement = /** @type {?} */ (null);\n      this._managedNodes = /** @type {?} */ (null);\n      this._inertManager = /** @type {?} */ (null);\n    }\n\n    /**\n     * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\n     */\n    get managedNodes() {\n      return new Set(this._managedNodes);\n    }\n\n    /** @return {boolean} */\n    get hasSavedAriaHidden() {\n      return this._savedAriaHidden !== null;\n    }\n\n    /** @param {?string} ariaHidden */\n    set savedAriaHidden(ariaHidden) {\n      this._savedAriaHidden = ariaHidden;\n    }\n\n    /** @return {?string} */\n    get savedAriaHidden() {\n      return this._savedAriaHidden;\n    }\n\n    /**\n     * @param {!Node} startNode\n     */\n    _makeSubtreeUnfocusable(startNode) {\n      composedTreeWalk(startNode, (node) => this._visitNode(node));\n\n      let activeElement = document.activeElement;\n\n      if (!document.body.contains(startNode)) {\n        // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n        let node = startNode;\n        /** @type {!ShadowRoot|undefined} */\n        let root = undefined;\n        while (node) {\n          if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n            root = /** @type {!ShadowRoot} */ (node);\n            break;\n          }\n          node = node.parentNode;\n        }\n        if (root) {\n          activeElement = root.activeElement;\n        }\n      }\n      if (startNode.contains(activeElement)) {\n        activeElement.blur();\n        // In IE11, if an element is already focused, and then set to tabindex=-1\n        // calling blur() will not actually move the focus.\n        // To work around this we call focus() on the body instead.\n        if (activeElement === document.activeElement) {\n          document.body.focus();\n        }\n      }\n    }\n\n    /**\n     * @param {!Node} node\n     */\n    _visitNode(node) {\n      if (node.nodeType !== Node.ELEMENT_NODE) {\n        return;\n      }\n      const element = /** @type {!Element} */ (node);\n\n      // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n      // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n      if (element !== this._rootElement && element.hasAttribute('inert')) {\n        this._adoptInertRoot(element);\n      }\n\n      if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n        this._manageNode(element);\n      }\n    }\n\n    /**\n     * Register the given node with this InertRoot and with InertManager.\n     * @param {!Node} node\n     */\n    _manageNode(node) {\n      const inertNode = this._inertManager.register(node, this);\n      this._managedNodes.add(inertNode);\n    }\n\n    /**\n     * Unregister the given node with this InertRoot and with InertManager.\n     * @param {!Node} node\n     */\n    _unmanageNode(node) {\n      const inertNode = this._inertManager.deregister(node, this);\n      if (inertNode) {\n        this._managedNodes.delete(inertNode);\n      }\n    }\n\n    /**\n     * Unregister the entire subtree starting at `startNode`.\n     * @param {!Node} startNode\n     */\n    _unmanageSubtree(startNode) {\n      composedTreeWalk(startNode, (node) => this._unmanageNode(node));\n    }\n\n    /**\n     * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n     * @param {!Element} node\n     */\n    _adoptInertRoot(node) {\n      let inertSubroot = this._inertManager.getInertRoot(node);\n\n      // During initialisation this inert root may not have been registered yet,\n      // so register it now if need be.\n      if (!inertSubroot) {\n        this._inertManager.setInert(node, true);\n        inertSubroot = this._inertManager.getInertRoot(node);\n      }\n\n      inertSubroot.managedNodes.forEach(function(savedInertNode) {\n        this._manageNode(savedInertNode.node);\n      }, this);\n    }\n\n    /**\n     * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n     * @param {!Array<!MutationRecord>} records\n     * @param {!MutationObserver} self\n     */\n    _onMutation(records, self) {\n      records.forEach(function(record) {\n        const target = /** @type {!Element} */ (record.target);\n        if (record.type === 'childList') {\n          // Manage added nodes\n          slice.call(record.addedNodes).forEach(function(node) {\n            this._makeSubtreeUnfocusable(node);\n          }, this);\n\n          // Un-manage removed nodes\n          slice.call(record.removedNodes).forEach(function(node) {\n            this._unmanageSubtree(node);\n          }, this);\n        } else if (record.type === 'attributes') {\n          if (record.attributeName === 'tabindex') {\n            // Re-initialise inert node if tabindex changes\n            this._manageNode(target);\n          } else if (target !== this._rootElement &&\n                    record.attributeName === 'inert' &&\n                    target.hasAttribute('inert')) {\n            // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n            // already managed nodes from this inert subroot.\n            this._adoptInertRoot(target);\n            const inertSubroot = this._inertManager.getInertRoot(target);\n            this._managedNodes.forEach(function(managedNode) {\n              if (target.contains(managedNode.node)) {\n                inertSubroot._manageNode(managedNode.node);\n              }\n            });\n          }\n        }\n      }, this);\n    }\n  }\n\n  /**\n   * `InertNode` initialises and manages a single inert node.\n   * A node is inert if it is a descendant of one or more inert root elements.\n   *\n   * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n   * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n   * is intrinsically focusable or not.\n   *\n   * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n   * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n   * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n   * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n   * or removes the `tabindex` attribute if the element is intrinsically focusable.\n   */\n  class InertNode {\n    /**\n     * @param {!Node} node A focusable element to be made inert.\n     * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\n     */\n    constructor(node, inertRoot) {\n      /** @type {!Node} */\n      this._node = node;\n\n      /** @type {boolean} */\n      this._overrodeFocusMethod = false;\n\n      /**\n       * @type {!Set<!InertRoot>} The set of descendant inert roots.\n       *    If and only if this set becomes empty, this node is no longer inert.\n       */\n      this._inertRoots = new Set([inertRoot]);\n\n      /** @type {?number} */\n      this._savedTabIndex = null;\n\n      /** @type {boolean} */\n      this._destroyed = false;\n\n      // Save any prior tabindex info and make this node untabbable\n      this.ensureUntabbable();\n    }\n\n    /**\n     * Call this whenever this object is about to become obsolete.\n     * This makes the managed node focusable again and deletes all of the previously stored state.\n     */\n    destructor() {\n      this._throwIfDestroyed();\n\n      if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n        const element = /** @type {!Element} */ (this._node);\n        if (this._savedTabIndex !== null) {\n          element.setAttribute('tabindex', this._savedTabIndex);\n        } else {\n          element.removeAttribute('tabindex');\n        }\n\n        // Use `delete` to restore native focus method.\n        if (this._overrodeFocusMethod) {\n          delete element.focus;\n        }\n      }\n\n      // See note in InertRoot.destructor for why we cast these nulls to ANY.\n      this._node = /** @type {?} */ (null);\n      this._inertRoots = /** @type {?} */ (null);\n      this._destroyed = true;\n    }\n\n    /**\n     * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n     * If the object has been destroyed, any attempt to access it will cause an exception.\n     */\n    get destroyed() {\n      return /** @type {!InertNode} */ (this)._destroyed;\n    }\n\n    /**\n     * Throw if user tries to access destroyed InertNode.\n     */\n    _throwIfDestroyed() {\n      if (this.destroyed) {\n        throw new Error('Trying to access destroyed InertNode');\n      }\n    }\n\n    /** @return {boolean} */\n    get hasSavedTabIndex() {\n      return this._savedTabIndex !== null;\n    }\n\n    /** @return {!Node} */\n    get node() {\n      this._throwIfDestroyed();\n      return this._node;\n    }\n\n    /** @param {?number} tabIndex */\n    set savedTabIndex(tabIndex) {\n      this._throwIfDestroyed();\n      this._savedTabIndex = tabIndex;\n    }\n\n    /** @return {?number} */\n    get savedTabIndex() {\n      this._throwIfDestroyed();\n      return this._savedTabIndex;\n    }\n\n    /** Save the existing tabindex value and make the node untabbable and unfocusable */\n    ensureUntabbable() {\n      if (this.node.nodeType !== Node.ELEMENT_NODE) {\n        return;\n      }\n      const element = /** @type {!Element} */ (this.node);\n      if (matches.call(element, _focusableElementsString)) {\n        if (/** @type {!HTMLElement} */ (element).tabIndex === -1 &&\n            this.hasSavedTabIndex) {\n          return;\n        }\n\n        if (element.hasAttribute('tabindex')) {\n          this._savedTabIndex = /** @type {!HTMLElement} */ (element).tabIndex;\n        }\n        element.setAttribute('tabindex', '-1');\n        if (element.nodeType === Node.ELEMENT_NODE) {\n          element.focus = function() {};\n          this._overrodeFocusMethod = true;\n        }\n      } else if (element.hasAttribute('tabindex')) {\n        this._savedTabIndex = /** @type {!HTMLElement} */ (element).tabIndex;\n        element.removeAttribute('tabindex');\n      }\n    }\n\n    /**\n     * Add another inert root to this inert node's set of managing inert roots.\n     * @param {!InertRoot} inertRoot\n     */\n    addInertRoot(inertRoot) {\n      this._throwIfDestroyed();\n      this._inertRoots.add(inertRoot);\n    }\n\n    /**\n     * Remove the given inert root from this inert node's set of managing inert roots.\n     * If the set of managing inert roots becomes empty, this node is no longer inert,\n     * so the object should be destroyed.\n     * @param {!InertRoot} inertRoot\n     */\n    removeInertRoot(inertRoot) {\n      this._throwIfDestroyed();\n      this._inertRoots.delete(inertRoot);\n      if (this._inertRoots.size === 0) {\n        this.destructor();\n      }\n    }\n  }\n\n  /**\n   * InertManager is a per-document singleton object which manages all inert roots and nodes.\n   *\n   * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n   * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n   * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n   * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n   * is created for each such node, via the `_managedNodes` map.\n   */\n  class InertManager {\n    /**\n     * @param {!Document} document\n     */\n    constructor(document) {\n      if (!document) {\n        throw new Error('Missing required argument; InertManager needs to wrap a document.');\n      }\n\n      /** @type {!Document} */\n      this._document = document;\n\n      /**\n       * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n       * @type {!Map<!Node, !InertNode>}\n       */\n      this._managedNodes = new Map();\n\n      /**\n       * All inert roots known to this InertManager. In a map to allow looking up by Node.\n       * @type {!Map<!Node, !InertRoot>}\n       */\n      this._inertRoots = new Map();\n\n      /**\n       * Observer for mutations on `document.body`.\n       * @type {!MutationObserver}\n       */\n      this._observer = new MutationObserver(this._watchForInert.bind(this));\n\n      // Add inert style.\n      addInertStyle(document.head || document.body || document.documentElement);\n\n      // Wait for document to be loaded.\n      if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n      } else {\n        this._onDocumentLoaded();\n      }\n    }\n\n    /**\n     * Set whether the given element should be an inert root or not.\n     * @param {!Element} root\n     * @param {boolean} inert\n     */\n    setInert(root, inert) {\n      if (inert) {\n        if (this._inertRoots.has(root)) { // element is already inert\n          return;\n        }\n\n        const inertRoot = new InertRoot(root, this);\n        root.setAttribute('inert', '');\n        this._inertRoots.set(root, inertRoot);\n        // If not contained in the document, it must be in a shadowRoot.\n        // Ensure inert styles are added there.\n        if (!this._document.body.contains(root)) {\n          let parent = root.parentNode;\n          while (parent) {\n            if (parent.nodeType === 11) {\n              addInertStyle(parent);\n            }\n            parent = parent.parentNode;\n          }\n        }\n      } else {\n        if (!this._inertRoots.has(root)) { // element is already non-inert\n          return;\n        }\n\n        const inertRoot = this._inertRoots.get(root);\n        inertRoot.destructor();\n        this._inertRoots.delete(root);\n        root.removeAttribute('inert');\n      }\n    }\n\n    /**\n     * Get the InertRoot object corresponding to the given inert root element, if any.\n     * @param {!Node} element\n     * @return {!InertRoot|undefined}\n     */\n    getInertRoot(element) {\n      return this._inertRoots.get(element);\n    }\n\n    /**\n     * Register the given InertRoot as managing the given node.\n     * In the case where the node has a previously existing inert root, this inert root will\n     * be added to its set of inert roots.\n     * @param {!Node} node\n     * @param {!InertRoot} inertRoot\n     * @return {!InertNode} inertNode\n     */\n    register(node, inertRoot) {\n      let inertNode = this._managedNodes.get(node);\n      if (inertNode !== undefined) { // node was already in an inert subtree\n        inertNode.addInertRoot(inertRoot);\n      } else {\n        inertNode = new InertNode(node, inertRoot);\n      }\n\n      this._managedNodes.set(node, inertNode);\n\n      return inertNode;\n    }\n\n    /**\n     * De-register the given InertRoot as managing the given inert node.\n     * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n     * node from the InertManager's set of managed nodes if it is destroyed.\n     * If the node is not currently managed, this is essentially a no-op.\n     * @param {!Node} node\n     * @param {!InertRoot} inertRoot\n     * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\n     */\n    deregister(node, inertRoot) {\n      const inertNode = this._managedNodes.get(node);\n      if (!inertNode) {\n        return null;\n      }\n\n      inertNode.removeInertRoot(inertRoot);\n      if (inertNode.destroyed) {\n        this._managedNodes.delete(node);\n      }\n\n      return inertNode;\n    }\n\n    /**\n     * Callback used when document has finished loading.\n     */\n    _onDocumentLoaded() {\n      // Find all inert roots in document and make them actually inert.\n      const inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n      inertElements.forEach(function(inertElement) {\n        this.setInert(inertElement, true);\n      }, this);\n\n      // Comment this out to use programmatic API only.\n      this._observer.observe(this._document.body || this._document.documentElement, {attributes: true, subtree: true, childList: true});\n    }\n\n    /**\n     * Callback used when mutation observer detects attribute changes.\n     * @param {!Array<!MutationRecord>} records\n     * @param {!MutationObserver} self\n     */\n    _watchForInert(records, self) {\n      const _this = this;\n      records.forEach(function(record) {\n        switch (record.type) {\n        case 'childList':\n          slice.call(record.addedNodes).forEach(function(node) {\n            if (node.nodeType !== Node.ELEMENT_NODE) {\n              return;\n            }\n            const inertElements = slice.call(node.querySelectorAll('[inert]'));\n            if (matches.call(node, '[inert]')) {\n              inertElements.unshift(node);\n            }\n            inertElements.forEach(function(inertElement) {\n              this.setInert(inertElement, true);\n            }, _this);\n          }, _this);\n          break;\n        case 'attributes':\n          if (record.attributeName !== 'inert') {\n            return;\n          }\n          const target = /** @type {!Element} */ (record.target);\n          const inert = target.hasAttribute('inert');\n          _this.setInert(target, inert);\n          break;\n        }\n      }, this);\n    }\n  }\n\n  /**\n   * Recursively walk the composed tree from |node|.\n   * @param {!Node} node\n   * @param {(function (!Element))=} callback Callback to be called for each element traversed,\n   *     before descending into child nodes.\n   * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n   */\n  function composedTreeWalk(node, callback, shadowRootAncestor) {\n    if (node.nodeType == Node.ELEMENT_NODE) {\n      const element = /** @type {!Element} */ (node);\n      if (callback) {\n        callback(element);\n      }\n\n      // Descend into node:\n      // If it has a ShadowRoot, ignore all child elements - these will be picked\n      // up by the <content> or <shadow> elements. Descend straight into the\n      // ShadowRoot.\n      const shadowRoot = /** @type {!HTMLElement} */ (element).shadowRoot;\n      if (shadowRoot) {\n        composedTreeWalk(shadowRoot, callback, shadowRoot);\n        return;\n      }\n\n      // If it is a <content> element, descend into distributed elements - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n      if (element.localName == 'content') {\n        const content = /** @type {!HTMLContentElement} */ (element);\n        // Verifies if ShadowDom v0 is supported.\n        const distributedNodes = content.getDistributedNodes ?\n          content.getDistributedNodes() : [];\n        for (let i = 0; i < distributedNodes.length; i++) {\n          composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n        }\n        return;\n      }\n\n      // If it is a <slot> element, descend into assigned nodes - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n      if (element.localName == 'slot') {\n        const slot = /** @type {!HTMLSlotElement} */ (element);\n        // Verify if ShadowDom v1 is supported.\n        const distributedNodes = slot.assignedNodes ?\n          slot.assignedNodes({flatten: true}) : [];\n        for (let i = 0; i < distributedNodes.length; i++) {\n          composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n        }\n        return;\n      }\n    }\n\n    // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n    // element, nor a <shadow> element recurse normally.\n    let child = node.firstChild;\n    while (child != null) {\n      composedTreeWalk(child, callback, shadowRootAncestor);\n      child = child.nextSibling;\n    }\n  }\n\n  /**\n   * Adds a style element to the node containing the inert specific styles\n   * @param {!Node} node\n   */\n  function addInertStyle(node) {\n    if (node.querySelector('style#inert-style, link#inert-style')) {\n      return;\n    }\n    const style = document.createElement('style');\n    style.setAttribute('id', 'inert-style');\n    style.textContent = '\\n'+\n                        '[inert] {\\n' +\n                        '  pointer-events: none;\\n' +\n                        '  cursor: default;\\n' +\n                        '}\\n' +\n                        '\\n' +\n                        '[inert], [inert] * {\\n' +\n                        '  -webkit-user-select: none;\\n' +\n                        '  -moz-user-select: none;\\n' +\n                        '  -ms-user-select: none;\\n' +\n                        '  user-select: none;\\n' +\n                        '}\\n';\n    node.appendChild(style);\n  }\n\n  /** @type {!InertManager} */\n  const inertManager = new InertManager(document);\n\n  if (!Element.prototype.hasOwnProperty('inert')) {\n    Object.defineProperty(Element.prototype, 'inert', {\n      enumerable: true,\n      /** @this {!Element} */\n      get: function() {\n        return this.hasAttribute('inert');\n      },\n      /** @this {!Element} */\n      set: function(inert) {\n        inertManager.setInert(this, inert);\n      },\n    });\n  }\n})();\n"],"names":["window","slice","Array","prototype","matches","Element","msMatchesSelector","_focusableElementsString","join","InertRoot","rootElement","inertManager","_inertManager","_rootElement","_managedNodes","Set","this","hasAttribute","_savedAriaHidden","getAttribute","setAttribute","_makeSubtreeUnfocusable","_observer","MutationObserver","_onMutation","bind","observe","attributes","childList","subtree","disconnect","removeAttribute","forEach","inertNode","_unmanageNode","node","startNode","_this2","_visitNode","activeElement","document","body","contains","root","undefined","nodeType","Node","DOCUMENT_FRAGMENT_NODE","parentNode","blur","focus","ELEMENT_NODE","element","_adoptInertRoot","call","_manageNode","register","add","deregister","_this3","inertSubroot","getInertRoot","setInert","managedNodes","savedInertNode","records","self","record","target","type","addedNodes","removedNodes","_unmanageSubtree","attributeName","managedNode","ariaHidden","InertNode","inertRoot","_node","_overrodeFocusMethod","_inertRoots","_savedTabIndex","_destroyed","ensureUntabbable","_throwIfDestroyed","destroyed","Error","tabIndex","hasSavedTabIndex","size","destructor","_document","Map","_watchForInert","head","documentElement","readyState","addEventListener","_onDocumentLoaded","inert","has","set","parent","get","addInertRoot","removeInertRoot","querySelectorAll","inertElement","_this","inertElements","unshift","hasOwnProperty","defineProperty","composedTreeWalk","callback","shadowRootAncestor","shadowRoot","localName","content","distributedNodes","getDistributedNodes","i","length","slot","assignedNodes","flatten","child","firstChild","nextSibling","addInertStyle","querySelector","style","createElement","textContent","appendChild"],"mappings":"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"}